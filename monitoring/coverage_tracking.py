"""
Test coverage tracking for CI/CD integration.

This module provides functions to record coverage data after each CI/CD run,
storing it in a time-series format for dashboard visualization.
"""

from __future__ import annotations

import json
import os
import re
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
from pathlib import Path
from typing import Optional

from monitoring.prometheus_exporter import record_coverage_metric
from monitoring.coverage_metrics import CoverageMetricsModel


def get_git_commit_hash() -> Optional[str]:
    """
    Get the current git commit hash.
    
    Returns:
        Commit hash string or None if not in a git repository
    """
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
            timeout=5
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        return None


def get_git_branch_name() -> Optional[str]:
    """
    Get the current git branch name.
    
    Returns:
        Branch name or None if not in a git repository
    """
    try:
        # Try to get branch from CI environment variables first
        branch = os.environ.get("GITHUB_REF_NAME") or os.environ.get("CI_COMMIT_REF_NAME")
        if branch:
            return branch
        
        # Fall back to git command
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
            timeout=5
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        return None


def parse_coverage_xml(coverage_xml_path: str) -> dict:
    """
    Parse coverage.xml file (generated by coverage.py or pytest-cov).
    
    Args:
        coverage_xml_path: Path to coverage.xml file
    
    Returns:
        Dictionary with coverage metrics:
        {
            'coverage_percentage': float,
            'total_lines': int,
            'covered_lines': int,
            'missing_lines': int,
            'branch_coverage': float (optional)
        }
    """
    tree = ET.parse(coverage_xml_path)
    root = tree.getroot()
    
    # Extract overall coverage from root element
    line_rate = float(root.get("line-rate", 0))
    branch_rate = root.get("branch-rate")
    
    # Calculate total, covered, and missing lines
    total_lines = int(root.get("lines-valid", 0))
    covered_lines = int(root.get("lines-covered", 0))
    missing_lines = total_lines - covered_lines
    
    coverage_percentage = line_rate * 100
    branch_coverage = float(branch_rate) * 100 if branch_rate else None
    
    return {
        "coverage_percentage": coverage_percentage,
        "total_lines": total_lines,
        "covered_lines": covered_lines,
        "missing_lines": missing_lines,
        "branch_coverage": branch_coverage,
    }


def parse_coverage_json(coverage_json_path: str) -> dict:
    """
    Parse coverage.json file (generated by coverage.py).
    
    Args:
        coverage_json_path: Path to coverage.json file
    
    Returns:
        Dictionary with coverage metrics
    """
    with open(coverage_json_path, "r") as f:
        data = json.load(f)
    
    totals = data.get("totals", {})
    
    # Extract coverage metrics
    covered_lines = totals.get("covered_lines", 0)
    num_statements = totals.get("num_statements", 0)
    missing_lines = num_statements - covered_lines
    
    coverage_percentage = totals.get("percent_covered", 0)
    branch_coverage = totals.get("percent_covered_branches")
    
    return {
        "coverage_percentage": coverage_percentage,
        "total_lines": num_statements,
        "covered_lines": covered_lines,
        "missing_lines": missing_lines,
        "branch_coverage": branch_coverage,
    }


def parse_pytest_cov_terminal(output: str) -> dict:
    """
    Parse pytest-cov terminal output to extract coverage metrics.
    
    Args:
        output: Terminal output from pytest --cov --cov-report=term
    
    Returns:
        Dictionary with coverage metrics
    """
    # Look for the TOTAL line in pytest-cov output
    # Example: "TOTAL                         1000     855    145    85%"
    pattern = r"TOTAL\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+(?:\.\d+)?)%"
    match = re.search(pattern, output)
    
    if not match:
        raise ValueError("Could not parse coverage from pytest output")
    
    total_lines = int(match.group(1))
    covered_lines = int(match.group(2))
    missing_lines = int(match.group(3))
    coverage_percentage = float(match.group(4))
    
    return {
        "coverage_percentage": coverage_percentage,
        "total_lines": total_lines,
        "covered_lines": covered_lines,
        "missing_lines": missing_lines,
        "branch_coverage": None,
    }


def store_coverage(
    coverage_percentage: float,
    total_lines: int,
    covered_lines: int,
    missing_lines: Optional[int] = None,
    branch_coverage: Optional[float] = None,
    test_suite: Optional[str] = None,
    commit_hash: Optional[str] = None,
    branch_name: Optional[str] = None,
    timestamp: Optional[datetime] = None,
) -> CoverageMetricsModel:
    """
    Store coverage data in the database with timestamp.
    
    This is the main function to record coverage after CI/CD runs.
    
    Args:
        coverage_percentage: Overall coverage percentage (0-100)
        total_lines: Total lines of code
        covered_lines: Lines covered by tests
        missing_lines: Lines not covered (calculated if not provided)
        branch_coverage: Branch coverage percentage (optional)
        test_suite: Name of test suite (e.g., "pytest", "unit-tests")
        commit_hash: Git commit hash (auto-detected if not provided)
        branch_name: Git branch name (auto-detected if not provided)
        timestamp: Timestamp for the metric (defaults to now)
    
    Returns:
        CoverageMetricsModel instance
    
    Example:
        >>> store_coverage(85.5, 1000, 855, test_suite="pytest")
        <CoverageMetricsModel(id=1, timestamp=..., coverage=85.5%)>
    """
    if missing_lines is None:
        missing_lines = total_lines - covered_lines
    
    if commit_hash is None:
        commit_hash = get_git_commit_hash()
    
    if branch_name is None:
        branch_name = get_git_branch_name()
    
    if timestamp is None:
        timestamp = datetime.utcnow()
    
    # Use the existing record_coverage_metric function
    metric = record_coverage_metric(
        coverage_percentage=coverage_percentage,
        total_lines=total_lines,
        covered_lines=covered_lines,
        missing_lines=missing_lines,
        branch_coverage=branch_coverage,
        test_suite=test_suite or "default",
        commit_hash=commit_hash,
        branch_name=branch_name,
    )
    
    return metric


def track_coverage_from_file(
    coverage_file: str,
    test_suite: Optional[str] = None,
    commit_hash: Optional[str] = None,
    branch_name: Optional[str] = None,
) -> CoverageMetricsModel:
    """
    Track coverage from a coverage report file (XML or JSON).
    
    Automatically detects file type and parses accordingly.
    
    Args:
        coverage_file: Path to coverage.xml or coverage.json
        test_suite: Name of test suite
        commit_hash: Git commit hash (auto-detected if not provided)
        branch_name: Git branch name (auto-detected if not provided)
    
    Returns:
        CoverageMetricsModel instance
    
    Example:
        >>> track_coverage_from_file("coverage.xml", test_suite="pytest")
        <CoverageMetricsModel(id=1, timestamp=..., coverage=85.5%)>
    """
    path = Path(coverage_file)
    
    if not path.exists():
        raise FileNotFoundError(f"Coverage file not found: {coverage_file}")
    
    if path.suffix == ".xml":
        metrics = parse_coverage_xml(str(path))
    elif path.suffix == ".json":
        metrics = parse_coverage_json(str(path))
    else:
        raise ValueError(f"Unsupported coverage file format: {path.suffix}")
    
    return store_coverage(
        coverage_percentage=metrics["coverage_percentage"],
        total_lines=metrics["total_lines"],
        covered_lines=metrics["covered_lines"],
        missing_lines=metrics["missing_lines"],
        branch_coverage=metrics.get("branch_coverage"),
        test_suite=test_suite,
        commit_hash=commit_hash,
        branch_name=branch_name,
    )


def track_coverage_from_pytest(
    test_suite: str = "pytest",
    commit_hash: Optional[str] = None,
    branch_name: Optional[str] = None,
) -> CoverageMetricsModel:
    """
    Run pytest with coverage and track the results.
    
    This function runs pytest with coverage reporting and automatically
    records the coverage metrics.
    
    Args:
        test_suite: Name of test suite
        commit_hash: Git commit hash (auto-detected if not provided)
        branch_name: Git branch name (auto-detected if not provided)
    
    Returns:
        CoverageMetricsModel instance
    
    Example:
        >>> track_coverage_from_pytest()
        <CoverageMetricsModel(id=1, timestamp=..., coverage=85.5%)>
    """
    # Run pytest with coverage
    result = subprocess.run(
        ["pytest", "--cov=.", "--cov-report=term", "--cov-report=xml"],
        capture_output=True,
        text=True,
        timeout=300,  # 5 minute timeout
    )
    
    # Parse XML report if available
    if Path("coverage.xml").exists():
        return track_coverage_from_file(
            "coverage.xml",
            test_suite=test_suite,
            commit_hash=commit_hash,
            branch_name=branch_name,
        )
    
    # Fall back to parsing terminal output
    if result.returncode == 0:
        metrics = parse_pytest_cov_terminal(result.stdout)
        return store_coverage(
            coverage_percentage=metrics["coverage_percentage"],
            total_lines=metrics["total_lines"],
            covered_lines=metrics["covered_lines"],
            missing_lines=metrics["missing_lines"],
            branch_coverage=metrics.get("branch_coverage"),
            test_suite=test_suite,
            commit_hash=commit_hash,
            branch_name=branch_name,
        )
    else:
        raise RuntimeError(f"pytest failed with return code {result.returncode}")


def get_coverage_trends(
    days: int = 30,
    test_suite: Optional[str] = None,
    branch_name: Optional[str] = None,
) -> list[CoverageMetricsModel]:
    """
    Get coverage trends over time from the database.
    
    Args:
        days: Number of days to look back (default: 30)
        test_suite: Filter by test suite (optional)
        branch_name: Filter by branch name (optional)
    
    Returns:
        List of CoverageMetricsModel instances ordered by timestamp
    """
    from datetime import timedelta
    from sqlalchemy import select, and_
    from sqlalchemy.orm import Session
    from database.postgresql_setup import get_sessionmaker
    
    sessionmaker = get_sessionmaker()
    session = sessionmaker()
    
    try:
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        stmt = select(CoverageMetricsModel).where(
            CoverageMetricsModel.timestamp >= cutoff_date
        )
        
        if test_suite:
            stmt = stmt.where(CoverageMetricsModel.test_suite == test_suite)
        
        if branch_name:
            stmt = stmt.where(CoverageMetricsModel.branch_name == branch_name)
        
        stmt = stmt.order_by(CoverageMetricsModel.timestamp.asc())
        
        return list(session.scalars(stmt).all())
    finally:
        session.close()


__all__ = [
    "store_coverage",
    "track_coverage_from_file",
    "track_coverage_from_pytest",
    "get_coverage_trends",
    "parse_coverage_xml",
    "parse_coverage_json",
    "parse_pytest_cov_terminal",
    "get_git_commit_hash",
    "get_git_branch_name",
]

